[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Tutorials and Demos\n\nUnify Existing Code\n\n\n\n\n  \n    \n      0.0: Unify\n      \n      \n    \n  \n  \n    \n      0.1: Compile\n      \n      \n    \n  \n  \n    \n      0.2: Transpile\n      \n      \n    \n  \n  \n    \n      1.0: Lazy vs Eager\n      \n      \n    \n  \n  \n    \n      1.1: Framework Selection\n      \n      \n    \n  \n  \n    \n      1.2: As a Decorator\n      \n      \n    \n  \n  \n    \n      1.3: Dynamic vs Static\n      \n      \n    \n  \n  \n    \n      2.0: Kornia\n      \n      \n    \n  \n  \n    \n      3.0: Perceiver\n      \n      \n    \n  \n  \n    \n      3.1: Stable Diffusion\n      \n      \n    \n  \n\n\nNo matching items\n\n\n\n\nTemp Demos\n\n\n\n  \n    \n      Basic Operations with Ivy\n      \n      \n    \n  \n  \n    \n      Compilation of a Basic Function\n      \n      \n    \n  \n  \n    \n      Deepmind PerceiverIO on GPU\n      \n      \n    \n  \n  \n    \n      Demo: Transpiling DeepMind's PerceiverIO\n      \n      \n    \n  \n  \n    \n      Ivy as a Transpiler Introduction\n      \n      \n    \n  \n  \n    \n      Resnet 18\n      \n      \n    \n  \n\n\nNo matching items"
  },
  {
    "objectID": "temp_demos/basic_operations_with_ivy.html",
    "href": "temp_demos/basic_operations_with_ivy.html",
    "title": "",
    "section": "",
    "text": "!pip install ivy-core\n!pip install torch\n!pip install tensorflow\n!pip install jax\n!pip install dm-haiku\n!pip install numpy\n\n\n\n\n\nimport ivy\n\n\n\n\nIvy is a unified machine learning framework that aims to provide a single interface for working with various machine learning libraries, such as Numpy, TensorFlow, PyTorch, and Jax. With Ivy, you can use the same code to build and train machine learning models, regardless of the underlying library being used. All you have to do is to change one line of code 😉\n\n\nWith Ivy, you can define your data and operations just once and easily switch between different frameworks. To do this, simply write your operations in Ivy and use the ivy.set_framework() function to change the underlying framework.\nP.S. there are some more advanced ways of handling backend frameworks in Ivy, so check it out in our Deep Dive.\n\n\n\nFirstly, let’s set the backend to Tensorflow\n\nivy.set_framework('tensorflow')\n\n\nx = ivy.array([1, 2, 3])\ny = ivy.array([4, 5, 6])\nprint((type(ivy.to_native(x))))\nprint(ivy.stack((x, y)))\n\n<class 'tensorflow.python.framework.ops.EagerTensor'>\ntf.Tensor(\n[[1 2 3]\n [4 5 6]], shape=(2, 3), dtype=int32)\n\n\nNow let’s try exactly the same code, but change the used backend framework to Pytorch.\n\nivy.set_framework('torch')\n\n\nx = ivy.array([1, 2, 3])\ny = ivy.array([4, 5, 6])\nprint((type(ivy.to_native(x))))\nprint(ivy.stack((x, y)))\n\n<class 'torch.Tensor'>\ntensor([[1, 2, 3],\n        [4, 5, 6]])\n\n\nYou can see that defined Ivy arrays have either tf.Tensor or torch.Tensor types underneath it without any need to worry about their types.\n\n\n\nBy saying that framework can be changed by just one line of code, we really mean it 🙂! By using Ivy as an ML framework, you do not need to worry about different function namings in different frameworks.\nTake a clip by value operator as an example. It performs the same operation across frameworks, but has different name and argument names. Numpy:\nnp.clip(a, a_min, a_max, out=None)\nTensforflow:\ntf.clip_by_value(t, clip_value_min, clip_value_max, name=None)\nPytorch:\ntorch.clamp(input, min=None, max=None, *, out=None)\nJax:\njax.numpy.clip(a, a_min=None, a_max=None, out=None)\nHere are some examples\n\nimport tensorflow as tf\nt = tf.constant([[-10., -1., 0.], [0., 2., 10.]])\nprint(tf.clip_by_value(t, clip_value_min=-1, clip_value_max=1))\n\nimport numpy as np\nn = np.array([[-10., -1., 0.], [0., 2., 10.]])\nprint(np.clip(n, a_min=-1, a_max=1))\n\ntf.Tensor(\n[[-1. -1.  0.]\n [ 0.  1.  1.]], shape=(2, 3), dtype=float32)\n[[-1. -1.  0.]\n [ 0.  1.  1.]]\n\n\nIvy allows you not to worry about such things. Now let’s do the same solely in Ivy.\n\nivy.set_framework('numpy')\ni = ivy.array([[-10., -1., 0.], [0., 2., 10.]])\nivy.clip(i, -1, 1)\n\narray([[-1., -1.,  0.],\n       [ 0.,  1.,  1.]])\n\n\n\nivy.set_framework('torch')\ni = ivy.array([[-10., -1., 0.], [0., 2., 10.]])\nivy.clip(i, -1, 1)\n\ntensor([[-1., -1.,  0.],\n        [ 0.,  1.,  1.]])\n\n\n\nivy.set_framework('tensorflow')\ni = ivy.array([[-10., -1., 0.], [0., 2., 10.]])\nivy.clip(i, -1, 1)\n\n<tf.Tensor: shape=(2, 3), dtype=float32, numpy=\narray([[-1., -1.,  0.],\n       [ 0.,  1.,  1.]], dtype=float32)>\n\n\n\nivy.set_framework('jax')\ni = ivy.array([[-10., -1., 0.], [0., 2., 10.]])\nivy.clip(i, -1, 1)\n\nDeviceArray([[-1., -1.,  0.],\n             [ 0.,  1.,  1.]], dtype=float32)\n\n\nAs you see, the only line that changed here is ivy.set_framework().\n\n\n\nFinally, functions defined in Ivy are framework agnostic. In the example below we show how Ivy’s concatenation function is compatible with tensors from different frameworks. This is the same for all Ivy functions. They can accept tensors from any framework and return the correct result.\n\nimport jax.numpy as jnp\nimport tensorflow as tf\nimport numpy as np\nimport torch\n\nimport ivy\n\njax_concatted   = ivy.concat((jnp.ones((1,)), jnp.ones((1,))), -1)\ntf_concatted    = ivy.concat((tf.ones((1,)), tf.ones((1,))), -1)\nnp_concatted    = ivy.concat((np.ones((1,)), np.ones((1,))), -1)\ntorch_concatted = ivy.concat((torch.ones((1,)), torch.ones((1,))), -1)\n\n\n\n\n\nFinally, let’s train a simple two layer network using Ivy.\n\n\nYou can change the framework to any of the following: torch, tensforflow, or jax.\n\nivy.set_framework('torch')\n\n\n\n\n\nclass MyModel(ivy.Module):\n    def __init__(self):\n        self.linear0 = ivy.Linear(3, 64)\n        self.linear1 = ivy.Linear(64, 1)\n        ivy.Module.__init__(self)\n\n    def _forward(self, x):\n        x = ivy.relu(self.linear0(x))\n        return ivy.sigmoid(self.linear1(x))\n\n\n\n\n\nmodel = MyModel()\n\n\n\n\n\noptimizer = ivy.Adam(1e-4)\n\n\n\n\n\nx_in = ivy.array([1., 2., 3.])\ntarget = ivy.array([0.])\n\n\n\n\n\ndef loss_fn(v):\n    out = model(x_in, v=v)\n    return ivy.reduce_mean((out - target)**2)[0]\n\n\n\n\n\nfor step in range(100):\n    loss, grads = ivy.execute_with_gradients(loss_fn, model.v)\n    model.v = optimizer.step(model.v, grads)\n    print('step {} loss {}'.format(step, ivy.to_numpy(loss).item()))\n\nprint('Finished training!')\n\nstep 0 loss 0.49040043354034424\nstep 1 loss 0.48975786566734314\nstep 2 loss 0.4892795979976654\nstep 3 loss 0.48886892199516296\nstep 4 loss 0.4884953498840332\nstep 5 loss 0.4881443977355957\nstep 6 loss 0.4878086447715759\nstep 7 loss 0.48748287558555603\nstep 8 loss 0.48716384172439575\nstep 9 loss 0.48684927821159363\nstep 10 loss 0.48653748631477356\nstep 11 loss 0.48622724413871765\nstep 12 loss 0.4859171509742737\nstep 13 loss 0.48560672998428345\nstep 14 loss 0.48529526591300964\nstep 15 loss 0.4849821627140045\nstep 16 loss 0.48466697335243225\nstep 17 loss 0.4843493402004242\nstep 18 loss 0.4840289056301117\nstep 19 loss 0.4837053418159485\nstep 20 loss 0.4833785891532898\nstep 21 loss 0.4830484390258789\nstep 22 loss 0.48271444439888\nstep 23 loss 0.48237672448158264\nstep 24 loss 0.48203518986701965\nstep 25 loss 0.48168954253196716\nstep 26 loss 0.4813397228717804\nstep 27 loss 0.4809857904911041\nstep 28 loss 0.48062753677368164\nstep 29 loss 0.48026490211486816\nstep 30 loss 0.479898065328598\nstep 31 loss 0.47952669858932495\nstep 32 loss 0.4791509211063385\nstep 33 loss 0.4787706732749939\nstep 34 loss 0.47838595509529114\nstep 35 loss 0.4779967665672302\nstep 36 loss 0.47760307788848877\nstep 37 loss 0.4772048890590668\nstep 38 loss 0.47680220007896423\nstep 39 loss 0.47639501094818115\nstep 40 loss 0.47598329186439514\nstep 41 loss 0.4755673110485077\nstep 42 loss 0.4751465618610382\nstep 43 loss 0.4747215211391449\nstep 44 loss 0.4742920398712158\nstep 45 loss 0.47385817766189575\nstep 46 loss 0.47341999411582947\nstep 47 loss 0.47297725081443787\nstep 48 loss 0.4725303053855896\nstep 49 loss 0.47207894921302795\nstep 50 loss 0.47162333130836487\nstep 51 loss 0.47116345167160034\nstep 52 loss 0.470699280500412\nstep 53 loss 0.47023090720176697\nstep 54 loss 0.4697583019733429\nstep 55 loss 0.46928152441978455\nstep 56 loss 0.46880054473876953\nstep 57 loss 0.4683155119419098\nstep 58 loss 0.4678264260292053\nstep 59 loss 0.46733325719833374\nstep 60 loss 0.46683603525161743\nstep 61 loss 0.4663347601890564\nstep 62 loss 0.4658295214176178\nstep 63 loss 0.465320348739624\nstep 64 loss 0.4648073613643646\nstep 65 loss 0.46429020166397095\nstep 66 loss 0.4637692868709564\nstep 67 loss 0.46324464678764343\nstep 68 loss 0.4627160429954529\nstep 69 loss 0.4621836841106415\nstep 70 loss 0.4616474211215973\nstep 71 loss 0.46110764145851135\nstep 72 loss 0.460563987493515\nstep 73 loss 0.4600166976451874\nstep 74 loss 0.45946577191352844\nstep 75 loss 0.45891112089157104\nstep 76 loss 0.45835286378860474\nstep 77 loss 0.4577910006046295\nstep 78 loss 0.45722562074661255\nstep 79 loss 0.45665669441223145\nstep 80 loss 0.4560841917991638\nstep 81 loss 0.4555082619190216\nstep 82 loss 0.45492875576019287\nstep 83 loss 0.45434585213661194\nstep 84 loss 0.45375964045524597\nstep 85 loss 0.4531698524951935\nstep 86 loss 0.4525766670703888\nstep 87 loss 0.45198020339012146\nstep 88 loss 0.4513803720474243\nstep 89 loss 0.4507772624492645\nstep 90 loss 0.4501707851886749\nstep 91 loss 0.4495610296726227\nstep 92 loss 0.4489481747150421\nstep 93 loss 0.44833192229270935\nstep 94 loss 0.4477125108242035\nstep 95 loss 0.44708991050720215\nstep 96 loss 0.44646409153938293\nstep 97 loss 0.44583529233932495\nstep 98 loss 0.4452032148838043\nstep 99 loss 0.44456806778907776\nFinished training!\n\n\n\nloss_fn(model.v)\n\ntensor(0.4439, grad_fn=<SelectBackward0>)\n\n\nWe hope that this short demo gives you a better understanding of basic Ivy functionality and got your interest in learning more about Ivy!"
  },
  {
    "objectID": "temp_demos/deepmind_perceiverio.html",
    "href": "temp_demos/deepmind_perceiverio.html",
    "title": "",
    "section": "",
    "text": "This notebook presents a demonstration of how to run the PercieverIO model on GPU using any of the following backends currently supported by ivy (numpy, torch, tensorflow and JAX). To find out more about ivy please feel free to checkout the ivy repo https://github.com/unifyai/ivy as well as the docs https://lets-unify.ai/ivy/index.html. Contributions are highly welcomed and you can interact with our community as well on discord https://discord.com/invite/G4aR9Q7DTN.\n\n\nNOTE: After running the cell below, you’ll need to restart the runtime for the newly installed kernel to work.\n\n# Step1\n!printf \"#Step1 start Download python3.8packages(tar.gz) of Share File from GoogleDrive\\n\"\n!printf \"10_wfp1U4rMzc20eiGNrdQa9V2S9ByJwV\" > ./FILE_ID ;\\\n printf \"wget  -O `cat ./FILE_ID`.tar.gz \\\"https://drive.google.com/uc?export=download&id=`cat ./FILE_ID`&confirm=t&\"|tee  ./FILE_ID_WGET_CMD  ;\\\n  printf \"`wget -q \"https://drive.google.com/uc?export=download&id=\\`cat ./FILE_ID\\`\" -O - | perl -pe 's/\\r*\\n//g' | perl -pe 's/^.*(uuid\\=[^\\\"]+)\\\".*$/${1}/g'`\"|tee -a ./FILE_ID_WGET_CMD  ;\\\n    printf \"&uc-download-link=Download anyway\\\"\" |tee -a ./FILE_ID_WGET_CMD ;\\\n      /bin/bash ./FILE_ID_WGET_CMD\n!printf \"#Step1 End Download python3.8packages(tar.gz) of Share File from GoogleDrive\\n\"\n\n# Step2 Install python3.8 interpreter and python3-pip\n!printf \"Step2 Start python3.8 interpreter and install python3-pip\\n\"\n!sudo apt-get install -y python3.8\n!sudo apt-get install -yf python3-pip\n!printf \"Step2 End install python3.8 interpreter and python3-pip\\n\"\n\n# Step3 \n!printf \"#Step3 Start Create ./dist-packages in the current directory, extract python3.8packages (tar.gz), and delete\\n\"\n!mkdir ./dist-packages\n!tar xvzf `cat ./FILE_ID`.tar.gz -C ./dist-packages\n!rm `cat ./FILE_ID`.tar.gz\n!printf \"#Step3 End Create ./dist-packages in the current directory, extract python3.8packages (tar.gz), and delete\\n\"\n\n# Step4 \n!printf \"# Step4 Start symlink python3.7 google* package to unzipped python3.8 package directory\\n\"\n!rm -fr /content/dist-packages/usr/local/lib/python3.8/dist-packages/google*\n!ls -d /usr/local/lib/python3.7/dist-packages/google* \\\n  | perl -pe 's/^(.+)$/sudo ln -sf ${1} \\/content\\/dist-packages\\/usr\\/local\\/lib\\/python3.8\\/dist-packages\\//g' \\\n    |/bin/bash -\n!ls -la /content/dist-packages/usr/local/lib/python3.8/dist-packages/google*\n!printf \"# Step4 End symlink the python3.7 google* package to the unzipped python3.8 package directory\\n\"\n\n# Step5\n!printf \"# Step5 Start and replace the unzipped python3.8 package directory with a regular python3.8 package directory with a symlink\\n\"\n!rm -fr /usr/local/lib/python3.8/dist-packages\n!sudo ln -s /content/dist-packages/usr/local/lib/python3.8/dist-packages /usr/local/lib/python3.8/\n!printf \"# Step5 End And symlink the unzipped python3.8 package directory to the regular python3.8 package directory\\n\"\n\n# Step6\n!printf \"# Step6 Start change python interpreter to 3.8\\n\"\n!printf \"python3.8 restart step 4\\n\"\n!sudo ln -sf `which python3.8` /etc/alternatives/python3\n!python --version\n!printf \"# Step6 End Change python interpreter to 3.8\\n\"\n\n# Run ipkykernel with Step7 3.8 python, name it \"engbjapanpython3.8\" and install the runtime separately\n!printf \"#Step7 Start Name engbjapanpython3.8 and start runtime (Python 3.8) ipykernel\\n\"\n!sudo python -m ipykernel install --name \"engbjapanpython3.8\" --user\n!printf \"#Step7 End Start the runtime (Python 3.8) ipykernel named engbjapanpython3.8\\n\"\n!printf \"When everything is finished, please execute ``Change runtime type and reconnect''\\n\"\n\n\nimport sys\nprint(\"User Current Version:-\", sys.version)\n\nUser Current Version:- 3.8.15 (default, Oct 12 2022, 19:14:39) \n[GCC 7.5.0]\n\n\n\n\n\n\n!git lfs clone --depth 1 https://github.com/unifyai/models.git\n\n\n!git clone --depth 1 https://github.com/unifyai/ivy.git \n\n\n\n\n\n!pip install models/ --upgrade\n\n\n!pip install ivy/\n\n\n# install the optional requirements to use JAX, tensorflow and torch backends\n!pip install -r ivy/requirements/optional.txt\n\n\n# Install jaxlib with with the corresponding CUDA version.\n!pip install  https://storage.googleapis.com/jax-releases/cuda11/jaxlib-0.3.14+cuda11.cudnn805-cp38-none-manylinux2014_x86_64.whl\n\n\n\n\n\n\n#!/usr/local/bin/python3.8\n\nimport os\nimport ivy\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nfrom ivy_models.transformers.helpers import FeedForward, PreNorm\nfrom ivy_models.transformers.perceiver_io import PerceiverIOSpec, PerceiverIO\n\n\n# Fetch sample images for inference\n!git clone https://github.com/ogbanugot/imagenet-samples.git\n\n#Fetch the class labels \n!git clone https://github.com/xmartlabs/caffeflow.git\n\n\ndef fetch_classes():\n  with open(\"/content/caffeflow/examples/imagenet/imagenet-classes.txt\", \"r\") as class_labels:\n    lines = class_labels.readlines()\n\n    classes = []\n    for l in lines:\n          classes.append(l.replace(\"\\n\", \"\"))\n    return classes\n\nclasses = fetch_classes()\nground_truth = [127, 31, 101, 32, 1]\npath_to_images = \"/content/imagenet-samples/\"\n\n\n#Helpers\n\ndef get_image(path, display=True, normalize=False):\n  img = Image.open(path).resize((224, 224))\n  if display:\n    return img\n\n  img = np.array(img)\n  img = img.astype(\"float32\")\n  img /= 255\n  if normalize:\n    mean = np.array([0.5, 0.5, 0.5])\n    std = np.array([0.5, 0.5, 0.5])\n    img[:, :] -= mean\n    img[:, :] /= std\n  return img\n\n\ndef imshow(image, ax=None, title=None, normalize=True):\n    if ax is None:\n        fig, ax = plt.subplots()\n    ax.imshow(image)\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    ax.tick_params(axis='both', length=0)\n    ax.set_xticklabels('')\n    ax.set_yticklabels('')\n    return ax\n\ndef show_results(path_to_images, preds, ground_truth):\n  # plot the images in the batch, along with predicted and true labels\n  fig = plt.figure(figsize=(25, 25))\n  idx = 0\n  for image in os.listdir(path_to_images):\n    if (image.endswith(\".JPEG\")):\n      this_dir = os.path.dirname(path_to_images)\n      image = get_image(os.path.join(this_dir, image))\n      ax = fig.add_subplot(1, 5, idx+1, xticks=[], yticks=[])\n      imshow(image, ax)\n      ax.set_title(\"{} ({})\".format(classes[preds[idx]].split(',')[0], classes[ground_truth[idx]].split(',')[0]),\n                  color=(\"green\" if preds[idx]==ground_truth[idx] else \"red\"))\n      idx += 1\n    \n\n\n# Perceiver IO #\n# -------------#\ndef perceiver_io_img_classification(path_to_images, normalize_images, device, batch_shape, img_dims, queries_dim, learn_query,\n                                         load_weights):\n    # params\n    input_dim = 3\n    num_input_axes = 2\n    output_dim = 1000\n    network_depth = 8 if load_weights else 1\n    num_lat_att_per_layer = 6 if load_weights else 1\n\n    model = PerceiverIO(PerceiverIOSpec(input_dim=input_dim,\n                                        num_input_axes=num_input_axes,\n                                        output_dim=output_dim,\n                                        queries_dim=queries_dim,\n                                        network_depth=network_depth,\n                                        learn_query=learn_query,\n                                        query_shape=[1],\n                                        num_fourier_freq_bands=64,\n                                        num_lat_att_per_layer=num_lat_att_per_layer,\n                                        device=device))\n    \n    this_dir = os.path.dirname(\"models/\")\n    # maybe load weights\n    if load_weights:\n        weight_fpath = os.path.join(this_dir, 'ivy_models/transformers/pretrained_weights/perceiver_io.pickled')\n        assert os.path.isfile(weight_fpath)\n        # noinspection PyBroadException\n        try:\n            v = ivy.Container.from_disk_as_pickled(weight_fpath)\n            v = ivy.asarray(v)\n        except Exception:\n            # If git large-file-storage is not enabled (for example when testing in github actions workflow), then the\n            #  code will fail here. A placeholder file does exist, but the file cannot be loaded as pickled variables.\n            raise\n        # noinspection PyUnboundLocalVariable\n        model = PerceiverIO(PerceiverIOSpec(input_dim=input_dim,\n                                            num_input_axes=num_input_axes,\n                                            output_dim=output_dim,\n                                            queries_dim=queries_dim,\n                                            network_depth=network_depth,\n                                            learn_query=learn_query,\n                                            query_shape=[1],\n                                            max_fourier_freq=img_dims[0],\n                                            num_fourier_freq_bands=64,\n                                            num_lat_att_per_layer=num_lat_att_per_layer,\n                                            device=device), v=v)\n        \n    logits = []\n    for image in os.listdir(path_to_images):\n      if (image.endswith(\".JPEG\")):\n        # inputs\n        this_dir = os.path.dirname(\"/content/imagenet-samples/\")\n\n        img = get_image(os.path.join(this_dir, image), False, normalize_images)\n        img = ivy.array(img[None], dtype='float32', device=device)\n        queries = None if learn_query else ivy.random_uniform(shape=batch_shape + [1, queries_dim], device=device)\n        # output\n        output = model(img, queries=queries)\n        logits.append(ivy.argmax(output, axis=2).to_numpy()[0][0])\n\n    return logits\n    \n\n\n\n\nivy.set_backend(\"torch\")\ndevice = \"gpu:0\"\nbatch_shape = [1]\nimg_dims = [224, 224]\nqueries_dim = 1024\nlearn_query = [True]\nload_weights = True\nnormalize_images=False\npreds = perceiver_io_img_classification(path_to_images, normalize_images, device, batch_shape, img_dims, queries_dim, learn_query,\n                                         load_weights)\n\nshow_results(path_to_images, preds, ground_truth)\n\n\n\n\n\n\n\n\nivy.set_backend(\"tensorflow\")\ndevice = \"gpu:0\"\nbatch_shape = [1]\nimg_dims = [224, 224]\nqueries_dim = 1024\nlearn_query = [True]\nload_weights = True\nnormalize_images=False\npreds = perceiver_io_img_classification(path_to_images, normalize_images, device, batch_shape, img_dims, queries_dim, learn_query,\n                                         load_weights)\n\nshow_results(path_to_images, preds, ground_truth)\n\n2022-11-03 20:04:33.817437: W tensorflow/core/common_runtime/gpu/gpu_bfc_allocator.cc:42] Overriding orig_value setting because the TF_FORCE_GPU_ALLOW_GROWTH environment variable is set. Original config value was 0.\n\n\n\n\n\n\n\n\n\nivy.set_backend(\"jax\")\ndevice = \"gpu:0\"\nbatch_shape = [1]\nimg_dims = [224, 224]\nqueries_dim = 1024\nlearn_query = [True]\nload_weights = True\nnormalize_images=False\npreds = perceiver_io_img_classification(path_to_images, normalize_images, device, batch_shape, img_dims, queries_dim, learn_query,\n                                         load_weights)\n\nshow_results(path_to_images, preds, ground_truth)\n\n\n\n\n\n\n\n\nivy.set_backend(\"numpy\")\ndevice = \"cpu\"\nbatch_shape = [1]\nimg_dims = [224, 224]\nqueries_dim = 1024\nlearn_query = [True]\nload_weights = True\nnormalize_images=False\npreds = perceiver_io_img_classification(path_to_images, normalize_images, device, batch_shape, img_dims, queries_dim, learn_query,\n                                         load_weights)\n\nshow_results(path_to_images, preds, ground_truth)\n\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend.\nWARNING:root:NumPy does not support autograd, declaring a 'variable' is identical to declaring an 'array' when using numpy backend."
  },
  {
    "objectID": "temp_demos/deepmind_perceiver_io.html",
    "href": "temp_demos/deepmind_perceiver_io.html",
    "title": "",
    "section": "",
    "text": "In this example, we will unify and transpile a classifier built on top of DeepMind’s original implementation of the PerceiverIO module written in JAX!\n\n\n\nDefining the model\nSome helper functions\nGetting images (and noise!) for the classifier\nCompiling the model\nUnifying the model\nTranspiling the model\n\nFirst of all, let’s import Ivy 🚀\n\nimport ivy\nfrom graph_compiler import compile\nfrom transpiler.transpiler import unify, transpile\n\n2023-01-13 16:05:01.516850: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libcudart.so.11.0'; dlerror: libcudart.so.11.0: cannot open shared object file: No such file or directory\n2023-01-13 16:05:01.516868: I tensorflow/stream_executor/cuda/cudart_stub.cc:29] Ignore above cudart dlerror if you do not have a GPU set up on your machine.\n\n\nWARNING:tensorflow:From /usr/local/lib/python3.8/dist-packages/tensorflow/python/util/decorator_utils.py:153: GraphKeys.VARIABLES (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.\nInstructions for updating:\nUse `tf.GraphKeys.GLOBAL_VARIABLES` instead.\n\n\n\n\n\n(Psst! The PerceiverIO code we will use comes from the original repo)\nIn order to define an image classifier on top of the PerceiverIO model, we must import some things first:\n\n# utils\nimport os\nimport cv2\nimport pickle\nimport imageio\nimport urllib.request\n# JAX imports\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport haiku as hk\nrng = jax.random.PRNGKey(23)\n# Perceiver implementation\nfrom demos.perceiver_io.perceiver_io_deepmind import perceiver, io_processors\nfrom demos.perceiver_io.perceiver_io_deepmind.imagenet_labels import IMAGENET_LABELS\n\nWARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n\n\nWe can now define the configuration of the Perceiver module\n\nIMAGE_SIZE = (224, 224)\n\nfourier_pos_configs = dict(\n    input_preprocessor=dict(\n        position_encoding_type=\"fourier\",\n        fourier_position_encoding_kwargs=dict(\n            concat_pos=True, max_resolution=(224, 224), num_bands=64, sine_only=False\n        ),\n        prep_type=\"pixels\",\n        spatial_downsample=1,\n    ),\n    encoder=dict(\n        cross_attend_widening_factor=1,\n        cross_attention_shape_for_attn=\"kv\",\n        dropout_prob=0,\n        num_blocks=8,\n        num_cross_attend_heads=1,\n        num_self_attend_heads=8,\n        num_self_attends_per_block=6,\n        num_z_channels=1024,\n        self_attend_widening_factor=1,\n        use_query_residual=True,\n        z_index_dim=512,\n        z_pos_enc_init_scale=0.02,\n    ),\n    decoder=dict(\n        num_z_channels=1024,\n        position_encoding_type=\"trainable\",\n        trainable_position_encoding_kwargs=dict(\n            init_scale=0.02,\n            num_channels=1024,\n        ),\n        use_query_residual=True,\n    ),\n)\n\nUsing the PerceiverIO module, we can now define an Imagenet classifier\n\ndef imagenet_classifier(config, images):\n    input_preprocessor = io_processors.ImagePreprocessor(**config[\"input_preprocessor\"])\n    encoder = perceiver.PerceiverEncoder(**config[\"encoder\"])\n    decoder = perceiver.ClassificationDecoder(1000, **config[\"decoder\"])\n    model = perceiver.Perceiver(\n        encoder=encoder, decoder=decoder, input_preprocessor=input_preprocessor\n    )\n    logits = model(images, is_training=False)\n    return logits\n\n\nimagenet_classifier = hk.transform_with_state(imagenet_classifier)\n\nWe also need to download the original parameters published by DeepMind if we want to save some computing 😅\nThankfully Ivy will transform those for us as well 😉\n\ncwd = os.getcwd()\ncheckpoint_path = os.path.join(cwd, \"demos\", \"imagenet_checkpoint.pystate\")\nif not os.path.exists(checkpoint_path):\n    url = \"https://storage.googleapis.com/perceiver_io/imagenet_fourier_position_encoding.pystate\"\n    _ = urllib.request.urlretrieve(url, checkpoint_path)\n\nwith open(checkpoint_path, \"rb\") as f:\n    ckpt = pickle.loads(f.read())\n\nparams = ckpt[\"params\"]\nstate = ckpt[\"state\"]\n\nFinally, let’s write a function that applies the downloaded parameters.\n\ndef imagenet_classify(image):\n    return imagenet_classifier.apply(params, state, rng, fourier_pos_configs, image)\n\n\n\n\nIn order to correctly use the classifier, we will need to define some preprocessing functions.\n\nMEAN_RGB = (0.485 * 255, 0.456 * 255, 0.406 * 255)\nSTDDEV_RGB = (0.229 * 255, 0.224 * 255, 0.225 * 255)\n\n\ndef normalize(im):\n    return (im - np.array(MEAN_RGB)) / np.array(STDDEV_RGB)\n\ndef denormalize(im):\n    return im * np.array(STDDEV_RGB) + np.array(MEAN_RGB)\n\n\ndef resize_and_center_crop(image):\n    \"\"\"Crops to center of image with padding then scales.\"\"\"\n    shape = image.shape\n    image_height = shape[0]\n    image_width = shape[1]\n    padded_center_crop_size = (\n        (224 / (224 + 32)) * np.minimum(image_height, image_width).astype(np.float32)\n    ).astype(np.int32)\n    offset_height = ((image_height - padded_center_crop_size) + 1) // 2\n    offset_width = ((image_width - padded_center_crop_size) + 1) // 2\n    crop_window = [\n        offset_height,\n        offset_width,\n        padded_center_crop_size,\n        padded_center_crop_size,\n    ]\n    image = image[\n        crop_window[0] : crop_window[0] + crop_window[2],\n        crop_window[1] : crop_window[1] + crop_window[3],\n    ]\n    return cv2.resize(image, (224, 224), interpolation=cv2.INTER_CUBIC)\n\nSame for the visualization of results, let’s write some helpers to have nice outputs!\n\nfrom matplotlib.pyplot import figure, imshow, axis\n\ndef print_labels(probs, indices):\n    for i in list(indices):\n        i = int(i)\n        print(f\"{IMAGENET_LABELS[i].split(',')[0][:15].ljust(20)}: {probs[i]}\")\n\ndef show_images_row(images):\n    fig = figure(figsize=(12,8))\n    number_of_files = len(images)\n    for i, image in enumerate(images):\n        a=fig.add_subplot(1,number_of_files,i+1)\n        imshow(np.array(image))\n        axis('off')\n\ndef show_device_array(device_array):\n    im = np.array(device_array[0])\n    im = denormalize(im)\n    im = im/256.0\n    im = np.clip(im, 0, 1)\n    fig = figure(figsize=(3,2))\n    imshow(im)\n    axis('off')\n\n\n\n\nTo compile and test the classifier we are going to need two types of images: - First, an image with random noise, which we will use to compile the graph while ensuring that input-specific information is not registered. - Secondly, a few images to test the compiled and transpiled models on!\n\ntest_urls = {\n    \"goldfish\": \"https://github.com/EliSchwartz/imagenet-sample-images/raw/master/n01443537_goldfish.JPEG\",\n    \"roof\": \"https://github.com/EliSchwartz/imagenet-sample-images/raw/master/n04435653_tile_roof.JPEG\",\n    \"camera\": \"https://github.com/EliSchwartz/imagenet-sample-images/raw/master/n04069434_reflex_camera.JPEG\",\n}\nimage_paths = {c: os.path.join(cwd, \"demos\", f\"{c}.jpg\") for c in test_urls.keys()}\n\nfor class_, image_path in image_paths.items():\n    if not os.path.exists(image_path):\n        url = test_urls[class_]\n        _ = urllib.request.urlretrieve(url, image_path)\nimgs = []\n\nfor image_path in image_paths.values():\n    with open(image_path, \"rb\") as f:\n        img = imageio.imread(f)\n        img = resize_and_center_crop(img)\n        imgs.append(img)\n\n# generate noise\nnoise = np.random.uniform(size=(224, 224, 3))\n\nLet’s see what we got:\n\nshow_images_row([noise, *imgs])\n\n\n\n\nLooking good! We can now convert the images to jax.numpy.Arrays.\n\nnoise = jnp.expand_dims(jnp.array(noise), 0)\n\nfor i, img in enumerate(imgs):\n    img = normalize(img)\n    img = jnp.array(img)[None]\n    imgs[i] = img\n\n\n\n\nThe first thing we can do with the model is compiling it into a graph, this way, we remove any part of the code that doesn’t contribute to the output directly which, you guessed it, makes it faster 🚀\n\nivy.set_backend(\"jax\")\ngraph = compile(imagenet_classify, noise)\n\nAfter compiling with the noisy image, let’s use our first real image to check the inference speed and the accuracy of the compiled result.\n\nimg = imgs[0]\nshow_device_array(img)\n\n\n\n\n\n%%time\noriginal_output, _ = imagenet_classify(img)\n\nCPU times: user 38 s, sys: 3.75 s, total: 41.7 s\nWall time: 8.35 s\n\n\n\n%%time\ncompiled_output, _ = graph(img)\n\nCPU times: user 14.2 s, sys: 959 ms, total: 15.2 s\nWall time: 3.21 s\n\n\n\nnp.allclose(original_output, compiled_output, atol=0.0001)\n\nTrue\n\n\nAs we can see above, the compiled graph is faster than the original model while yielding the same result!\n\n\n\nBy unifying the model, we will get a model that can be used with any ML framework. Don’t forget that we aren’t just converting the inputs, all the operations within the model will happen in your framework of choice!\n\nivy_graph = unify(\n    imagenet_classify,\n    original_backend=\"jax\",\n    args=(noise,),\n)\n\nLet’s pick the second image as an example:\n\nimg = imgs[1]\nshow_device_array(img)\n\n\n\n\nAnd calculate the output using each one of the frameworks:\n\noriginal_logits, _ = imagenet_classify(img)\n\n\nivy.set_backend(\"jax\")\njax_logits, _ = ivy_graph(img)\nnp.allclose(original_logits, jax_logits, atol=0.0001)\n\nTrue\n\n\n\nivy.set_backend(\"torch\")\ntorch_logits, _ = ivy_graph(img)\nnp.allclose(original_logits, torch_logits, atol=0.0001)\n\nTrue\n\n\n\nivy.set_backend(\"tensorflow\")\ntf_logits, _ = ivy_graph(img)\nnp.allclose(original_logits, tf_logits, atol=0.0001)\n\nTrue\n\n\n\nivy.set_backend(\"numpy\")\nnp_logits, _ = ivy_graph(img)\nnp.allclose(original_logits, np_logits, atol=0.0001)\n\nTrue\n\n\nAs expected, running the unified model in any of the frameworks results in the same outputs as the original model!\n\n\n\nUnifying is pretty cool, but sometimes we need to use code from a framework in projects which are already built using another framework. If we have, a project written in PyTorch but still want to use the PerceiverIO module, we can use transpile to convert it directly into a PyTorch module. It only takes one line of code. Let’s test this with the third image.\n\nimg = imgs[2]\nshow_device_array(img)\n\n\n\n\n\nivy.set_backend(\"jax\")\ntranspiled_graph = transpile(imagenet_classify, original_backend=\"jax\", to=\"torch\", args=(noise,))\n\nFirst, we call the original function, which as expected, yields a JAX DeviceArray instance.\n\nlogits, _ = imagenet_classify(img)\ntype(logits)\n\njaxlib.xla_extension.DeviceArray\n\n\nIf we now call the transpiled graph, we can see that the output is, in fact, a torch.Tensor, due to the transpiled graph being now fully composed of torch code.\n\ntranspiled_logits, _ = transpiled_graph(img)\ntype(transpiled_logits)\n\ntorch.Tensor\n\n\nOnce again, we can check the predictions of both the original and the transpiled model, to see that their results match correctly!\n\n_, indices = ivy.to_numpy(ivy.top_k(logits[0], 5))\nprobs = ivy.to_numpy(ivy.softmax(logits[0]))\nprint(\"Original - Top 5 labels:\")\nprint_labels(probs, indices)\n\nOriginal - Top 5 labels:\nreflex camera       : 0.9125176974309779\nPolaroid camera     : 0.0062769926141319965\nlens cap            : 0.002572748444021628\ntripod              : 0.0013543223305103043\nwasher              : 0.0008780962522585626\n\n\n\nivy.set_backend(\"torch\")\n_, indices = ivy.top_k(transpiled_logits[0], 5)\nprobs = ivy.to_numpy(ivy.softmax(transpiled_logits[0]))\nprint(\"Transpiled - Top 5 labels:\")\nprint_labels(probs, indices)\n\nTranspiled - Top 5 labels:\nreflex camera       : 0.9125140905380249\nPolaroid camera     : 0.006276924163103104\nlens cap            : 0.0025728049222379923\ntripod              : 0.0013543171808123589\nwasher              : 0.0008780973730608821\n\n\n\n\n\nThat’s pretty much it! Did you have an Image Augmentation pipeline which used Kornia or some other PyTorch specific package? Maybe some complex meta-learning functions already written in Torch? Now you are free to use, finetune, or deploy DeepMind’s PerceiverIO model and trained parameters in every framework and every hardware!"
  },
  {
    "objectID": "temp_demos/ivy_as_a_transpiler_intro.html",
    "href": "temp_demos/ivy_as_a_transpiler_intro.html",
    "title": "",
    "section": "",
    "text": "Head to our website\nCreate an account and generate an API Key\nSet theIVY_API_KEYenvironment variable to your generated key\n\n\n\n\n    def transpile(\n        self,\n        *objs,\n        to: Optional[str] = None,\n        args: Optional[tuple] = None,\n        kwargs: Optional[dict] = None,\n    ) -> Callable:\n        \"\"\"\n        objs\n            the functions, models or modules to be transpiled\n        to \n            the framework to be transpiled to\n        args\n            The positional arguments passed to the function for tracing\n        kwargs\n            The keyword arguments passed to the function for tracing\n        \"\"\"\n\nTranspile either functions, trainable models or importable python modules, with any number and combo permitted\nIf no “objs” are provided, the function returns a new transpilation function which receives only one object as input, making it usable as a decorator\nIf neither “args” nor “kwargs” are specified, then the transpilation will occur lazily, upon the first call of the transpiled function, otherwise transpilation is eager\n\n\n\nTelemetry helps us better understand how users are interacting with the transpiler & how to make it better, we specifcally collect: 1. Invocations of the transpiler 2. graph representation of the transpiled object(s) 3. General machine information (e.g. number of CPUs, GPUs, OS)\nadd option to opt-out?\n\n\n\n\n!pip install kornia ivy-core\n!wget https://raw.githubusercontent.com/unifyai/unifyai.github.io/master/img/externally_linked/logo.png -O image.png\n\n\nfrom google.colab.patches import cv2_imshow\nimport cv2 \n\nimg = cv2.imread(\"image.png\")\ncv2_imshow(img)\n\n\n\n\n\nimport os\nimport ivy\nimport kornia\nimport jax.numpy as jnp\n\n# set the API key\nos.envrion[\"IVY_API_KEY\"] = \"\"\n\n# load image into jax \nimg = jnp.array(cv2.imread('image.png'))/255\nimg = jnp.expand_dims(jnp.transpose(img, (2, 0, 1)), 0)\n\n# transpile function lazily\ncanny = ivy.transpile(kornia.feature.canny,to='jax')\n\ncv2_imshow(canny(img))\n\n\nimport tensorflow as tf\n# load image in tensorflow\noriginal_img = tf.array(cv2.imread('image.png'))/255\noriginal_img = tf.expand_dims(tf.transpose(img, (2, 0, 1)), 0)\n\n\n#@title Run transpilation in eager/lazy mode { display-mode: \"form\" }\nimport torch \nmode = \"Lazy\" #@param [\"Eager\", \"Lazy\"]\nfn_args = (original_img,) if mode == \"Eager\" else None\n\n@ivy.transpile(to=\"tensorflow\",args=fn_args)\ndef dilate_edges(img):\n  edges = kornia.filters.canny(img)[1]\n  return kornia.morphology.dilation(edges,torch.ones(7,7))\n\n\n%%time\nnew_img = dilate_edges(original_img)\n\nYou selected Eager\n\n\n\ncv2_imshow(new_img)\n\n\n\n\n\n# transpile module lazily\nkornia = ivy.transpile(kornia,to=\"tensorflow\")\n\ndef dilate_edges(img):\n  edges = kornia.filters.canny(img)[1]\n  return kornia.morphology.dilation(edges,torch.ones(7,7))\n\n%%time\nnew_img = dilate_edges(original_img)\n\n\ncv2_imshow(img)\n\n\n\n\n\nimport haiku as hk\n\nnum_classes = 10\nhk_model = hk.nets.ResNet18(num_classes)\n\n# transpile to framework of your choice\ntorch_model = ivy.transpile(hk_model,to=torch.nn.Module)\nkeras_model = ivy.transpile(hk_model,to=tf.keras.Model)\n\n\n# visualize function counting as in the odsc talk"
  },
  {
    "objectID": "temp_demos/compilation_of_a_basic_function.html",
    "href": "temp_demos/compilation_of_a_basic_function.html",
    "title": "",
    "section": "",
    "text": "!pip install ivy-core\n!pip install numpy\n\n\n\n\n\nimport ivy\nimport numpy as np\n\n\n\n\n\nimport ivy_compiler as ic\n\n\n\n\n\n\n\nivy.set_backend(\"numpy\")\n\n\n\n\n\nx = ivy.array([1., 2., 3.])\n\n\n\n\nIvy can compile any function that produce numerical outputs. Compiler track values from inputs to outputs and produce a computational graph from those operations and will ignore anything that does not affect final output value. It will ignore all intermediate dummy variables, operations, and print statements.\n\ndef original_fn(x):\n    for _ in range(100000):\n        pass\n    y = (x + 3) * 4\n    z = (x ** y) - 3 * y\n    x = x**2\n    f = ivy.var(y)\n    k = np.cos(x)\n    m = ivy.sin(k)\n    o = np.tan(m)\n    return x\n\n\n\n\n\ncomp_fn = ic.compile_graph(original_fn, x)\n\n\n\n\nGiven that function is compiled, its result can be compared to the original function.\n\nexpected_result = original_fn(x)\ncompiled_result = comp_fn(x)\n\nprint(expected_result)\nprint(compiled_result)\n\nAs you can see, both functions produce the same results, which is what we want 🙂!\n\n\n\n\nSimilarly to compiling functions, you can compile a neural network. The compilation works in exactly the same manner and will ignore all irrelevant opeations.\n\n\n\nclass Network(ivy.Module):\n    def __init__(self):\n        self._layer = ivy.Linear(3, 3)\n        ivy.Module.__init__(self)\n\n    def _forward(self, x):\n        return self._layer(x)\n\n\n\n\n\nnet = Network()\n\n\n\n\n\nx = ivy.array([1., 2., 3.])\n\n\n\n\n\ncompiled_net = ic.compile_graph(net, x)\n\n\n\n\n\nprint(net(x))\nprint(compiled_net(x))"
  },
  {
    "objectID": "temp_demos/compilation_of_various_models/resnet_18.html",
    "href": "temp_demos/compilation_of_various_models/resnet_18.html",
    "title": "",
    "section": "",
    "text": "Resnet 18\n\nLets first install Ivy (pip install ivy-core) and compatable version of matplotlib to be able to see generated graph\n\n!pip install ivy-core\n!pip install matplotlib==3.5.2\n!pip install networkx==2.8.4\n\nLooking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/\nCollecting ivy-core\n  Downloading ivy_core-1.1.10-py3-none-any.whl (228 kB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 228.8/228.8 KB 19.0 MB/s eta 0:00:00\nCollecting einops\n  Downloading einops-0.6.0-py3-none-any.whl (41 kB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 41.6/41.6 KB 6.0 MB/s eta 0:00:00\nRequirement already satisfied: psutil in /usr/local/lib/python3.8/dist-packages (from ivy-core) (5.4.8)\nRequirement already satisfied: termcolor in /usr/local/lib/python3.8/dist-packages (from ivy-core) (2.1.1)\nCollecting nvidia-ml-py3\n  Downloading nvidia-ml-py3-7.352.0.tar.gz (19 kB)\n  Preparing metadata (setup.py) ... done\nRequirement already satisfied: numpy in /usr/local/lib/python3.8/dist-packages (from ivy-core) (1.21.6)\nBuilding wheels for collected packages: nvidia-ml-py3\n  Building wheel for nvidia-ml-py3 (setup.py) ... done\n  Created wheel for nvidia-ml-py3: filename=nvidia_ml_py3-7.352.0-py3-none-any.whl size=19190 sha256=241af6b4a51197474b0da3ee7bfa32d847756c8f0d93b51448655d6458312714\n  Stored in directory: /root/.cache/pip/wheels/b9/b1/68/cb4feab29709d4155310d29a421389665dcab9eb3b679b527b\nSuccessfully built nvidia-ml-py3\nInstalling collected packages: nvidia-ml-py3, einops, ivy-core\nSuccessfully installed einops-0.6.0 ivy-core-1.1.10 nvidia-ml-py3-7.352.0\nLooking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/\nCollecting matplotlib==3.5.2\n  Downloading matplotlib-3.5.2-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.whl (11.3 MB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 11.3/11.3 MB 82.1 MB/s eta 0:00:00\nRequirement already satisfied: cycler>=0.10 in /usr/local/lib/python3.8/dist-packages (from matplotlib==3.5.2) (0.11.0)\nRequirement already satisfied: packaging>=20.0 in /usr/local/lib/python3.8/dist-packages (from matplotlib==3.5.2) (21.3)\nCollecting fonttools>=4.22.0\n  Downloading fonttools-4.38.0-py3-none-any.whl (965 kB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 965.4/965.4 KB 69.7 MB/s eta 0:00:00\nRequirement already satisfied: pillow>=6.2.0 in /usr/local/lib/python3.8/dist-packages (from matplotlib==3.5.2) (7.1.2)\nRequirement already satisfied: pyparsing>=2.2.1 in /usr/local/lib/python3.8/dist-packages (from matplotlib==3.5.2) (3.0.9)\nRequirement already satisfied: numpy>=1.17 in /usr/local/lib/python3.8/dist-packages (from matplotlib==3.5.2) (1.21.6)\nRequirement already satisfied: kiwisolver>=1.0.1 in /usr/local/lib/python3.8/dist-packages (from matplotlib==3.5.2) (1.4.4)\nRequirement already satisfied: python-dateutil>=2.7 in /usr/local/lib/python3.8/dist-packages (from matplotlib==3.5.2) (2.8.2)\nRequirement already satisfied: six>=1.5 in /usr/local/lib/python3.8/dist-packages (from python-dateutil>=2.7->matplotlib==3.5.2) (1.15.0)\nInstalling collected packages: fonttools, matplotlib\n  Attempting uninstall: matplotlib\n    Found existing installation: matplotlib 3.2.2\n    Uninstalling matplotlib-3.2.2:\n      Successfully uninstalled matplotlib-3.2.2\nSuccessfully installed fonttools-4.38.0 matplotlib-3.5.2\n\n\nUnable to display output for mime type(s): application/vnd.colab-display-data+json\n\n\nLooking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/\nCollecting networkx==2.8.4\n  Downloading networkx-2.8.4-py3-none-any.whl (2.0 MB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.0/2.0 MB 65.0 MB/s eta 0:00:00\nInstalling collected packages: networkx\n  Attempting uninstall: networkx\n    Found existing installation: networkx 2.8.8\n    Uninstalling networkx-2.8.8:\n      Successfully uninstalled networkx-2.8.8\nSuccessfully installed networkx-2.8.4\n\n\n\nimport ivy\nimport numpy as np\nimport timeit\nimport torch\nimport urllib\nfrom ivy import compile_graph\nfrom ivy import show_graph\nimport matplotlib.pyplot as plt\nfrom IPython.display import Image\n\n\n\n\nHere we load resnet18 pytorch model. Copy model to chosen device and convert the model into ivy (using ivy.to_ivy_module).\n\n\nThen we compile the model (using compile_graph) and check if it is working as expected.\n\nivy.set_framework(\"torch\")\n# dev = 'cpu'\ndev = 'gpu:0'\nbatch_size = 1\nimage_dims = [64,64]\n\ntry:\n    model = torch.hub.load(\n        \"pytorch/vision:v0.10.0\", \"resnet18\", pretrained=True\n    )\nexcept urllib.error.URLError:\n  pass\n\nnet = ivy.to_ivy_module(model.to('cuda:0' if dev == 'gpu:0' else 'cpu'))\n\nx0 = ivy.random_uniform(\n    low=0.0,\n    high=1.0,\n    shape=[batch_size] + [3] + image_dims,\n    dev_str=dev,\n)\nx1 = ivy.random_uniform(\n    low=0.0,\n    high=1.0,\n    shape=[batch_size] + [3] + image_dims,\n    dev_str=dev,\n)\n\ncomp_network, graph = compile_graph(net, x0, return_graph=True, time_chronological=False)\n\nshow_graph(\n    net,\n    x0,\n    save_to_disk=True,\n    fname='resnet18'\n)\n\n\nret0_nc = net(x0)\nret1_nc = net(x1)\n\nassert not np.allclose(ivy.to_numpy(ret0_nc), ivy.to_numpy(ret1_nc))\n\nret0_c = comp_network(x0)\nret1_c = comp_network(x1)\n\nassert not np.allclose(ivy.to_numpy(ret0_c), ivy.to_numpy(ret1_c))\nassert np.allclose(ivy.to_numpy(ret0_nc), ivy.to_numpy(ret0_c))\nassert np.allclose(ivy.to_numpy(ret1_nc), ivy.to_numpy(ret1_c))\n\nUsing cache found in /root/.cache/torch/hub/pytorch_vision_v0.10.0\n/usr/local/lib/python3.8/dist-packages/torch/distributed/distributed_c10d.py:262: UserWarning: torch.distributed.reduce_op is deprecated, please use torch.distributed.ReduceOp instead\n  warnings.warn(\n\n\n\n\nLets compare inference speed of original network and compiled network\n\n\nIn general compiled network is faster due to graph compiler optimizations\n\nN = 1000\nres = timeit.timeit(lambda: net(x0), number=N)\nprint(res/N,'ms')\n\n0.004645566477999864 ms\n\n\n\nN = 1000\nres = timeit.timeit(lambda: comp_network(x0), number=N)\nprint(res/N,'ms')\n\n0.0044566806820000695 ms\n\n\n\n\nHere is how graph of the network looks like\n\nImage('resnet18.png')\n\n\n\n\n\n\nBy passing return_graph=True parameter to compile_graph you can obtain graph object. It has _all_functions attribute that stors all the functions in order of their execution.\n\n\nIf time_chronological=True the order of functions will the same as in the definition of network. If time_chronological=False Ivy’s graph compiler will try to find optimal order for better inference speed without affecting the accuracy.\n\ncomp_network, graph = compile_graph(net, x0, return_graph=True, time_chronological=True)\nprint([fn.__name__ for fn in graph._all_functions])\n\n/usr/local/lib/python3.8/dist-packages/torch/distributed/distributed_c10d.py:262: UserWarning: torch.distributed.reduce_op is deprecated, please use torch.distributed.ReduceOp instead\n  warnings.warn(\n\n\n['conv2d', 'batch_norm', 'relu', 'max_pool2d', 'conv2d', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'conv2d', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'conv2d', 'conv2d', 'batch_norm', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'conv2d', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'conv2d', 'conv2d', 'batch_norm', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'conv2d', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'conv2d', 'conv2d', 'batch_norm', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'conv2d', 'batch_norm', 'relu', 'conv2d', 'batch_norm', '__iadd__', 'relu', 'adaptive_avg_pool2d', 'flatten', 'linear']"
  },
  {
    "objectID": "unify_existing_code/2_libraries/2_0_kornia.html",
    "href": "unify_existing_code/2_libraries/2_0_kornia.html",
    "title": "",
    "section": "",
    "text": "2.0: Kornia"
  },
  {
    "objectID": "unify_existing_code/3_models/3_0_perceiver.html",
    "href": "unify_existing_code/3_models/3_0_perceiver.html",
    "title": "",
    "section": "",
    "text": "3.0: Perceiver"
  },
  {
    "objectID": "unify_existing_code/3_models/3_1_stable_diffusion.html",
    "href": "unify_existing_code/3_models/3_1_stable_diffusion.html",
    "title": "",
    "section": "",
    "text": "3.1: Stable Diffusion"
  },
  {
    "objectID": "unify_existing_code/0_building_blocks/0_2_transpile.html",
    "href": "unify_existing_code/0_building_blocks/0_2_transpile.html",
    "title": "",
    "section": "",
    "text": "In this example, we transpile the original normalize function from torch to jax in one line of code. This is a common use case, where there is one target framework in mind.\n\n\n\n\n\n\n\nUsing what we learnt in the previous two notebooks for Unify and Compile, the workflow for converting directly from torch to jax would be as follows, first unifying to ivy code, and then compiling to the jax backend:\n\nimport ivy\nimport torch\nivy.set_backend(\"jax\")\n\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nnormalize = ivy.compile(ivy.unify(normalize))\n\nnormalize is now compiled to machine-code, specifically for jax, ready to be integrated into your wider jax project.\nThis workflow is common, and so in order to avoid repeated calls to ivy.unify followed by ivy.compile, there is another convenience function ivy.transpile, which basically acts as a shorthand for this pair of function calls:\n\nnormalize = ivy.transpile(normalize)\n\nAgain, normalize is now compiled to machine-code, specifically for jax, ready to be integrated into your wider jax project.\n\n\nThat’s it, you can now transpile code from one framework to another with one line of code! That concludes the collection of notebooks on the “Building Blocks”. However, there are still many other important topics to master before you’re ready to unify ML code like a pro 🥷. In the next collection of notebooks “The Basics”, we’ll be learning about the various different ways that ivy.unify, ivy.compile and ivy.transpile can be called, and what implications each of these have."
  },
  {
    "objectID": "unify_existing_code/0_building_blocks/0_0_unify.html",
    "href": "unify_existing_code/0_building_blocks/0_0_unify.html",
    "title": "",
    "section": "",
    "text": "In this example, we unify a simple torch function normalize. We then show how this newly unified normalize function can be used alongside any ML framework!\n\n\n\n\n\n\n\nFirstly, let’s import the dependencies and define the torch function.\n\nimport ivy\nimport torch\n\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nNow, let’s unify the function!\n\nnormalize = ivy.unify(normalize)\n\nAnd that’s it! The normalize function can now be used with any ML framework. It’s as simple as that!\nSo, let’s give it a try!\n\n# import numpy\nimport numpy as np\n\n# create random numpy arrays for testing\nx = np.randon.uniform(size=10)\nmean = np.mean(x)\nstd = np.std(x)\n\n# numpy\nprint(normalize(x, mean, std))\n\n# jax\nimport jax.numpy as jnp\nx_ = jnp.array(x)\nmean_ = jnp.array(mean)\nstd_ = jnp.array(std)\nprint(normalize(x_, mean_, std_))\n\n# tensorflow\nimport tensorflow as tf\nx_ = tf.constant(x)\nmean_ = tf.constant(mean)\nstd_ = tf.constant(std)\nprint(normalize(x_, mean_, std_))\n\n# torch\nx_ = torch.tensor(x)\nmean_ = torch.tensor(mean)\nstd_ = torch.tensor(std)\nprint(normalize(x_, mean_, std_))\n\nWe can see that the new normalize function can operate with any ML framework. ivy.unify is able to detect that the original normalize function is implemented in torch by using the inspection module. ivy.unify then converts the framework-specific torch implementation into a framework-agnostic ivy implementation, which is compatible with all frameworks.\n\n\nThat’s it, you can now unify ML code! However, there are several other important topics to master before you’re ready to unify ML code like a pro 🥷. Next, we’ll be learning how to make our unified Ivy code run much more efficiently! ⚡"
  },
  {
    "objectID": "unify_existing_code/0_building_blocks/0_1_compile.html",
    "href": "unify_existing_code/0_building_blocks/0_1_compile.html",
    "title": "",
    "section": "",
    "text": "In this example, we compile our simple unified ivy function normalize from the last notebook. We then show how this newly compiled normalize function exhibits much better runtime performance than the non-compiled version.\n\n\n\n\n\n\n\nFirstly, let’s pick up where we left off in the last notebook, with our unified normalize function:\n\nimport ivy\nimport torch\n\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nnormalize = ivy.unify(normalize)\n\nFor the purpose of illustration, we will use jax as our backend framework:\n\n# set ivy's backend to jax\nivy.set_backend(\"jax\")\n\n# Import jax numpy API\nimport jax.numpy as jnp\n\n# create random jax arrays for testing\nx = jnp.randon.uniform(size=10)\nmean = jnp.mean(x)\nstd = jnp.std(x)\n\nAs in the previous example, the unified function can be executed like so (in this case it will trigger lazy unification, see the Lazy vs Eager section for more details):\n\nnormalize(x, mean, std)\n\nWhen calling this function, all of ivy’s function wrapping is included in the call stack of normalize, which adds runtime overhead. In general, ivy.compile strips any arbitrary function down to its constituent functions in the functional API of the target framework. It will then also be compiled to machine-code if the target framework supports low-level compiling (via functions such as tf.function, torch.jit.script, torch.jit.trace, torch.compile, jax.jit etc.). The code can be compiled like so:\n\ncomp = ivy.compile(normalize)  # compiles to jax, due to ivy.set_backend\n\nThe compiled function can be executed in exactly the same manner as the non-compiled function (in this case it will also trigger lazy compilation, see the Lazy vs Eager section for more details):\n\ncomp(x, mean, std)\n\nThe machine-code compilation can be turned off by setting the argument low_level = False, in which case it will simply return a chain of Python function in the functional API of the target framework (in this case JAX). This will still improve the runtime efficiency over the original un-compiled version due to the removal of all ivy wrapping overhead, but it will not be as runtime efficient as the low-level compiled version:\n\npartial_comp = ivy.compile(normalize, low_level=False)\n\nAgain, the compiled function can be executed in exactly the same manner as the non-compiled function (in this case it will also trigger lazy compilation, see the Lazy vs Eager section for more details):\n\npartial_comp(x, mean, std)\n\nWith all lazy unification and compilation calls now performed (which all increase runtime during the very first call of the function), we can now assess the runtime efficiencies of each function:\n\nivy.time_function(normalize)(x, mean, std)\nivy.time_function(partial_comp)(x, mean, std)\nivy.time_function(comp)(x, mean, std)\n\nAs expected, we can see that the slowest is normalize, which includes all ivy wrapping overhead. Next is partial_comp which has no wrapping overhead but is still expressed entirely in Python, without compiling to low-level code. The fastest is comp because the wrapping overhead is removed and the function is compiled to low-level code for maximal efficiency.\n\n\nThat’s it, you can now compile ivy code for more efficient inference! However, there are several other important topics to master before you’re ready to unify ML code like a pro 🥷. Next, we’ll be learning how to transpile code from one framework to another in a single line of code 🔄"
  },
  {
    "objectID": "unify_existing_code/1_the_basics/1_2_as_a_decorator.html",
    "href": "unify_existing_code/1_the_basics/1_2_as_a_decorator.html",
    "title": "",
    "section": "",
    "text": "ivy.unify, ivy.compile and ivy.transpile can all be called either as a function decorator or as a standalone function. All examples in the Building Blocks section and all previous examples in The Basics are called as standalone functions. In this section, we’ll see how they can each be instead called as function decorators.\n\n\n\n\n\n\n\n\n\nFirstly, let’s create the dummy numpy arrays as before:\n\n# import numpy\nimport numpy as np\n\n# create random numpy arrays for testing\nx = np.randon.uniform(size=10)\nmean = np.mean(x)\nstd = np.std(x)\n\nLet’s assume that our target framework is tensorflow:\n\nimport tensorflow as tf\nivy.set_backend(\"tensorflow\")\n\nx = tf.constant(x)\nmean = tf.constant(mean)\nstd = tf.constant(std)\n\nIn the example below, the ivy.unify function is called as a decorator.\n\nimport ivy\nimport torch\n\n@ivy.unify\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nThe function can still be called either eagerly or lazily when calling as a decorator. The example above is lazy, whereas the example below is eager:\n\n@ivy.unify(args=(x, mean, std))\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nThe same is true for all other arguments, such as from for specifying the source framework locally. This argument can be passed when ivy.unify is used as a decorator.\n\n\n\nIn the example below, the ivy.compile function is also called as a decorator.\n\n@ivy.compile\n@ivy.unify\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nLikewise, the function can still be called either eagerly or lazily when calling as a decorator. The example above is lazy, whereas the example below is eager:\n\n@ivy.compile(args=(x, mean, std))\n@ivy.unify\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nThe same is true for all other arguments, such as to for specifying the target framework locally. This argument can be passed when ivy.compile is used as a decorator.\n\n\n\nIn the example below, the ivy.transpile function is called as a decorator.\n\n@ivy.transpile\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nThe function can still be called either eagerly or lazily when calling as a decorator. The example above is lazy, whereas the example below is eager:\n\n@ivy.transpile(args=(x, mean, std))\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nThe same is true for all other arguments, such as from for specifying the source framework locally, and to for specifying the target framework locally. These arguments can be passed when ivy.transpile is used as a decorator.\n\n\n\nThat’s it, you now know how ivy.unify, ivy.compile and ivy.transpile can all be used as function decorators! However, there are several other important topics to master before you’re ready to unify ML code like a pro 🥷. Next, we’ll be exploring the difference between dynamic vs static computation graphs!"
  },
  {
    "objectID": "unify_existing_code/1_the_basics/1_3_dynamic_vs_static.html",
    "href": "unify_existing_code/1_the_basics/1_3_dynamic_vs_static.html",
    "title": "",
    "section": "",
    "text": "The functions ivy.unify, ivy.compile and ivy.transpile can all be executed either in dynamic mode or static mode. In this demo, we explore how this mode is set, and what implications this has.\n\n\n\n\n\n\n\n\n\nDynamic mode means that Python dynamic control flow is included in the extracted computation graph. For example, if statements, for loops, while loops etc. would all be included if dynamic mode is set to True.\n\n\n\nStatic mode means the opposite, where Python dynamic control flow is not included in the extracted computation graph. if statements, for loops, while loops etc. would all be excluded if dynamic mode is set to False."
  },
  {
    "objectID": "unify_existing_code/1_the_basics/1_0_lazy_vs_eager.html",
    "href": "unify_existing_code/1_the_basics/1_0_lazy_vs_eager.html",
    "title": "",
    "section": "",
    "text": "ivy.unify, ivy.compile and ivy.transpile can all be performed either eagerly or lazily. All examples in the Building Blocks section are performed lazily, which means that the unification, compilation, or transpilation process actually occurs during the first call of the returned function. This is because all three of these processes depend on function tracing, which requires function arguments to use for the tracing. Alternatively, the arguments can be provided during the ivy.unify, ivy.compile or ivy.transpile call itself, in which case the process is performed eagerly. We show some simple examples for each case below.\n\n\n\n\n\n\n\n\n\nConsider again this simple torch function:\n\nimport ivy\nimport torch\n\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nLet’s also create the dummy numpy arrays as before:\n\n# import NumPy\nimport numpy as np\n\n# create random numpy arrays for testing\nx = np.randon.uniform(size=10)\nmean = np.mean(x)\nstd = np.std(x)\n\nLet’s assume that our target framework is tensorflow:\n\nimport tensorflow as tf\nivy.set_backend(\"tensorflow\")\n\nx = tf.constant(x)\nmean = tf.constant(mean)\nstd = tf.constant(std)\n\nIn the example below, the function is unified lazily, which means the first function call will execute slowly, as this is when the unification process actually occurs.\n\nnorm = ivy.unify(normalize)\nnorm(x, mean, std) # slow, lazy unification\nnorm(x, mean, std) # fast, unified on previous call\n\nHowever, in the following example the unification occurs eagerly, and both function calls will be fast:\n\nnorm = ivy.unify(normalize, args=(x, mean, std))\nnorm(x, mean, std) # fast, unified at ivy.unify\nnorm(x, mean, std) # fast, unified at ivy.unify\n\n\n\n\nThe same is true for compiling. In the example below, the function is compiled lazily, which means the first function call will execute slowly, as this is when the compilation process actually occurs.\n\nnorm_comp = ivy.compile(norm)\nnorm_comp(x, mean, std) # slow, lazy compilation\nnorm_comp(x, mean, std) # fast, compiled on previous call\n\nHowever, in the following example the compilation occurs eagerly, and both function calls will be fast:\n\nnorm_comp = ivy.compile(norm, args=(x, mean, std))\nnorm_comp(x, mean, std) # fast, compiled at ivy.compile\nnorm_comp(x, mean, std) # fast, compiled at ivy.compile\n\n\n\n\nThe same is true for transpiling. In the example below, the function is transpiled lazily, which means the first function call will execute slowly, as this is when the transpilation process actually occurs.\n\nnorm_trans = ivy.transpile(normalize)\nnorm_trans(x, mean, std) # slow, lazy transpilation\nnorm_trans(x, mean, std) # fast, transpiled on previous call\n\nHowever, in the following example the transpilation occurs eagerly, and both function calls will be fast:\n\nnorm_trans = ivy.transpile(normalize, args=(x, mean, std))\nnorm_trans(x, mean, std) # fast, transpiled at ivy.transpile\nnorm_trans(x, mean, std) # fast, transpiled at ivy.transpile\n\n\n\n\nThat’s it, you now know the difference between lazy vs eager execution for ivy.unify, ivy.compile and ivy.transpile! However, there are several other important topics to master before you’re ready to unify ML code like a pro 🥷. Next, we’ll be learning how the frameworks are selected, either inferred from the inputs and the function, specified globally, or specified locally. We’ll also learn what the implications are for each of these approaches!"
  },
  {
    "objectID": "unify_existing_code/1_the_basics/1_1_framework_selection.html",
    "href": "unify_existing_code/1_the_basics/1_1_framework_selection.html",
    "title": "",
    "section": "",
    "text": "The source and target frameworks for ivy.unify, ivy.compile and ivy.transpile can be: (a) inferred from the arguments and/or inspection of the function, (b) specified globally or (c) specified locally. All examples in the Building Blocks either infer the source and target frameworks or specify them globally (via ivy.set_backend). We’ll explore these various options, and also explore which modes take priority. For these examples, all functions are called eagerly. Please go through the Lazy vs Eager notebook if you haven’t already.\n\n\n\n\n\n\n\n\n\nConsider again this simple torch function:\n\nimport ivy\nimport torch\n\ndef normalize(x, mean, std):\n    return torch.div(torch.sub(x, mean), std)\n\nLet’s also create the dummy data as before:\n\n# import numpy\nimport numpy as np\n\n# create random numpy arrays for testing\nx = np.randon.uniform(size=10)\nmean = np.mean(x)\nstd = np.std(x)\n\nThis time, let’s assume that our target framework is jax:\n\nimport jax.numpy as jnp\n\nx = jnp.array(x)\nmean = jnp.array(mean)\nstd = jnp.array(std)\n\nIn the example below, the source framework of torch is inferred from the function normalize.\n\nnorm = ivy.unify(normalize, args=(x, mean, std))\n\nAs mentioned in the Unify notebook, ivy.unify is able to detect that the original normalize function is implemented in torch by using the inspection module. ivy.unify then converts the framework-specific torch implementation into a framework-agnostic Ivy implementation, which is compatible with all frameworks.\nFor some functions, this would not be possible. Consider the example below:\n\ndef normalize_via_operators(x, mean, std):\n    return (x - mean) / std\n\nThere is no way to determine the source framework from this function via the inspection module. This code uses built-in operators only, which are compatible with all ML frameworks. You might therefore think “this is already unified”, but that’s not true. Every ML framework has its own unique rules for broadcasting shapes and data types for elementwise functions, which must all be taken into account when converting code to ivy.\nRather than inferring the framework, the framework can be specified locally as follows:\n\nnorm = ivy.unify(normalize_via_operators, args=(x, mean, std), from=\"torch\")\n\nNote that in all of the examples above, the arguments are in fact jax arrays. During function tracing, the jax arrays are converted to torch tensors automatically.\n\n\n\nIn the example below, the target framework of jax is inferred from the arguments.\n\nnorm_comp = ivy.compile(norm, args=(x, mean, std))\n\nHowever, if the Ivy function norm was purely generative (not consuming any arrays in the input), then this would not be possible. In such cases, we could set the target framework globally like so. If the type of the arguments conflicts with the globally set backend, then an error will be thrown.\n\nivy.set_backend(\"jax\")\nnorm_comp = ivy.compile(norm, args=(x, mean, std))\n\nFinally, the target framework can be provided locally. This will override any globally set backend, but again the arguments must be of the correct type in order to avoid errors.\n\nivy.set_backend(\"tensorflow\") # a different global backend\nnorm_comp = ivy.compile(norm, args=(x, mean, std), to=\"jax\") # doesn't matter, jax specified locally\n\n\n\n\nAll consideration for both ivy.unify and ivy.compile are combined for ivy.transpile, which is effectively shorthand for the combination of these two functions (as explained in the Transpile section).\nIn the example below, the source framework of torch is inferred from the function normalize, and the target framework of jax is inferred from the arguments.\n\nnorm = ivy.transpile(normalize, args=(x, mean, std))\n\nIn the example below, the source framework is specified locally (would be necessary if transpiling normalize_via_operators for example) and the target framework of jax is inferred from the arguments.\n\nnorm = ivy.transpile(normalize, args=(x, mean, std), from=\"torch\")\n\nIn the example below, the source framework is specified locally and the target framework of jax is specified globally. This might be necessary if there are no array arguments for the function.\n\nivy.set_backend(\"jax\")\nnorm = ivy.transpile(normalize, args=(x, mean, std), from=\"torch\")\n\nAs with ivy.compile, the target framework can be provided locally. This will override any globally set backend, but again the arguments must be of the correct type in order to avoid errors.\nIn the example below, the source framework is specified locally and the target framework of jax is also specified locally. Again, this might be necessary if there are no array arguments for the function.\n\nivy.set_backend(\"tensorflow\") # a different global backend\nnorm = ivy.transpile(normalize, args=(x, mean, std), from=\"torch\", to=\"jax\") # doesn't matter, jax specified locally\n\n\n\n\nThat’s it, you now know the difference between inferring, locally specifying, and globally specifying source and target frameworks for ivy.unify, ivy.compile and ivy.transpile! However, there are several other important topics to master before you’re ready to unify ML code like a pro 🥷. Next, we’ll be exploring how these three functions can all be called as function decorators!"
  }
]